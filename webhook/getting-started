
After joining the kernel development group, install the necessities.

sudo dnf install -y python-devel
sudo dnf install -y libtool
sudo dnf install -y python-bugzilla
pip install --user setuptools
python3 -m pip install --user git+https://gitlab.com/cki-project/cki-lib.git/#egg=cki_lib
pip3 install --user --force-reinstall -e .  # <- don't forget the dot at the end!

Go here to generate personal token.
https://gitlab.com/profile/personal_access_tokens

Personal token: QxycutXinLXzApdNDnEn

Then ...

export COM_GITLAB_TOKEN=QxycutXinLXzApdNDnEn
export GITLAB_TOKENS='{"gitlab.com": "COM_GITLAB_TOKEN"}'

... and finally ...

$ CKI_LOGGING_LEVEL=DEBUG \
	python3 -m webhook.bugzilla \
	--merge-request https://gitlab.com/redhat/rhel/kernel/8.y/kernel-test/-/merge_requests/68 \
	--note request-bz-evaluation

<herton> if you run with IS_PRODUCTION=true it'll update the gitlab merge request with a comment in gitlab
<herton> so let's say you're testing and is happy with it, you can run:
<herton> CKI_LOGGING_LEVEL=DEBUG IS_PRODUCTION=true python3 -m webhook.bugzilla --merge-request https://gitlab.com/redhat/rhel/kernel/8.y/kernel-test/-/merge_requests/68 --note request-bz-evaluation
<herton> and instead of getting the result on the console it updates the gitlab merge request with a comment

RESULTS from first command:

2020-10-14T15:44:54.211 - [INFO] - cki.webhook.bugzilla - Received object_kind:note for key:cmdline
2020-10-14T15:44:54.212 - [DEBUG] - cki.webhook.bugzilla - Checking note request

2020-10-14T15:44:55.464 - [DEBUG] - cki.cki_lib.gitlab - Requested: https://gitlab.com/api/v4/projects/redhat%2Frhel%2Fkernel%2F8%2Ey%2Fkernel-test
2020-10-14T15:44:55.706 - [DEBUG] - cki.cki_lib.gitlab - Requested: https://gitlab.com/api/v4/projects/20363472/merge_requests/68
2020-10-14T15:44:55.709 - [DEBUG] - cki.webhook.bugzilla - Removing bzValidationFails

2020-10-14T15:44:55.709 - [DEBUG] - cki.webhook.bugzilla - Forcing MR state back to State.NEW
2020-10-14T15:44:55.709 - [DEBUG] - cki.webhook.bugzilla - Computing next state from state State.NEW
2020-10-14T15:44:55.710 - [INFO] - cki.webhook.bugzilla - Running bz validation

2020-10-14T15:44:55.943 - [DEBUG] - cki.cki_lib.gitlab - Requested: https://gitlab.com/api/v4/projects/20363472/merge_requests/68/commits
2020-10-14T15:44:56.110 - [DEBUG] - cki.cki_lib.gitlab - Requested: https://gitlab.com/api/v4/projects/20363472/repository/commits/433b8bfefc457a3a6f13cfcc33a470740c4ce198
2020-10-14T15:44:56.270 - [DEBUG] - cki.cki_lib.gitlab - Requested: https://gitlab.com/api/v4/projects/20363472/repository/commits/85d222990797b28012cb42597a6f137bf7679beb
2020-10-14T15:44:56.431 - [DEBUG] - cki.cki_lib.gitlab - Requested: https://gitlab.com/api/v4/projects/20363472/repository/commits/85d222990797b28012cb42597a6f137bf7679beb/diff
2020-10-14T15:44:56.432 - [INFO] - cki.webhook.bugzilla - [{'old_path': 'Documentation/filesystems/debugfs.txt', 'new_path': 'Documentation/filesystems/debugfs.txt', 'a_mode': '100644', 'b_mode': '100644', 'new_file': False, 'renamed_file': False, 'deleted_file': False, 'diff': '@@ -178,13 +178,17 @@ byte offsets over a base for the register block.\n \n If you want to dump an u32 array in debugfs, you can create file with:\n \n+    struct debugfs_u32_array {\n+\tu32 *array;\n+\tu32 n_elements;\n+    };\n+\n     void debugfs_create_u32_array(const char *name, umode_t mode,\n \t\t\tstruct dentry *parent,\n-\t\t\tu32 *array, u32 elements);\n+\t\t\tstruct debugfs_u32_array *array);\n \n-The "array" argument provides data, and the "elements" argument is\n-the number of elements in the array. Note: Once array is created its\n-size can not be changed.\n+The "array" argument wraps a pointer to the array\'s data and the number\n+of its elements. Note: Once array is created its size can not be changed.\n \n There is a helper function to create device related seq_file:\n \n'}, {'old_path': 'fs/debugfs/file.c', 'new_path': 'fs/debugfs/file.c', 'a_mode': '100644', 'b_mode': '100644', 'new_file': False, 'renamed_file': False, 'deleted_file': False, 'diff': '@@ -942,11 +942,6 @@ struct dentry *debugfs_create_blob(const char *name, umode_t mode,\n }\n EXPORT_SYMBOL_GPL(debugfs_create_blob);\n \n-struct array_data {\n-\tvoid *array;\n-\tu32 elements;\n-};\n-\n static size_t u32_format_array(char *buf, size_t bufsize,\n \t\t\t       u32 *array, int array_size)\n {\n@@ -967,8 +962,8 @@ static size_t u32_format_array(char *buf, size_t bufsize,\n \n static int u32_array_open(struct inode *inode, struct file *file)\n {\n-\tstruct array_data *data = inode->i_private;\n-\tint size, elements = data->elements;\n+\tstruct debugfs_u32_array *data = inode->i_private;\n+\tint size, elements = data->n_elements;\n \tchar *buf;\n \n \t/*\n@@ -983,7 +978,7 @@ static int u32_array_open(struct inode *inode, struct file *file)\n \tbuf[size] = 0;\n \n \tfile->private_data = buf;\n-\tu32_format_array(buf, size, data->array, data->elements);\n+\tu32_format_array(buf, size, data->array, data->n_elements);\n \n \treturn nonseekable_open(inode, file);\n }\n@@ -1020,8 +1015,7 @@ static const struct file_operations u32_array_fops = {\n  * @parent: a pointer to the parent dentry for this file.  This should be a\n  *          directory dentry if set.  If this parameter is %NULL, then the\n  *          file will be created in the root of the debugfs filesystem.\n- * @array: u32 array that provides data.\n- * @elements: total number of elements in the array.\n+ * @array: wrapper struct containing data pointer and size of the array.\n  *\n  * This function creates a file in debugfs with the given name that exports\n  * @array as data. If the @mode variable is so set it can be read from.\n@@ -1029,17 +1023,10 @@ static const struct file_operations u32_array_fops = {\n  * Once array is created its size can not be changed.\n  */\n void debugfs_create_u32_array(const char *name, umode_t mode,\n-\t\t\t      struct dentry *parent, u32 *array, u32 elements)\n+\t\t\t      struct dentry *parent,\n+\t\t\t      struct debugfs_u32_array *array)\n {\n-\tstruct array_data *data = kmalloc(sizeof(*data), GFP_KERNEL);\n-\n-\tif (data == NULL)\n-\t\treturn;\n-\n-\tdata->array = array;\n-\tdata->elements = elements;\n-\n-\tdebugfs_create_file_unsafe(name, mode, parent, data, &u32_array_fops);\n+\tdebugfs_create_file_unsafe(name, mode, parent, array, &u32_array_fops);\n }\n EXPORT_SYMBOL_GPL(debugfs_create_u32_array);\n \n'}, {'old_path': 'include/linux/debugfs.h', 'new_path': 'include/linux/debugfs.h', 'a_mode': '100644', 'b_mode': '100644', 'new_file': False, 'renamed_file': False, 'deleted_file': False, 'diff': '@@ -37,6 +37,11 @@ struct debugfs_regset32 {\n \tvoid __iomem *base;\n };\n \n+struct debugfs_u32_array {\n+\tu32 *array;\n+\tu32 n_elements;\n+};\n+\n extern struct dentry *arch_debugfs_dir;\n \n #define DEFINE_DEBUGFS_ATTRIBUTE(__fops, __get, __set, __fmt)\t\t\\\n@@ -134,7 +139,8 @@ void debugfs_print_regs32(struct seq_file *s, const struct debugfs_reg32 *regs,\n \t\t\t  int nregs, void __iomem *base, char *prefix);\n \n void debugfs_create_u32_array(const char *name, umode_t mode,\n-\t\t\t      struct dentry *parent, u32 *array, u32 elements);\n+\t\t\t      struct dentry *parent,\n+\t\t\t      struct debugfs_u32_array *array);\n \n struct dentry *debugfs_create_devm_seqfile(struct device *dev, const char *name,\n \t\t\t\t\t   struct dentry *parent,\n@@ -353,8 +359,8 @@ static inline bool debugfs_initialized(void)\n }\n \n static inline void debugfs_create_u32_array(const char *name, umode_t mode,\n-\t\t\t\t\t    struct dentry *parent, u32 *array,\n-\t\t\t\t\t    u32 elements)\n+\t\t\t\t\t    struct dentry *parent,\n+\t\t\t\t\t    struct debugfs_u32_array *array)\n {\n }\n \n'}, {'old_path': 'mm/cma.h', 'new_path': 'mm/cma.h', 'a_mode': '100644', 'b_mode': '100644', 'new_file': False, 'renamed_file': False, 'deleted_file': False, 'diff': '@@ -2,6 +2,8 @@\n #ifndef __MM_CMA_H__\n #define __MM_CMA_H__\n \n+#include <linux/debugfs.h>\n+\n struct cma {\n \tunsigned long   base_pfn;\n \tunsigned long   count;\n@@ -11,6 +13,7 @@ struct cma {\n #ifdef CONFIG_CMA_DEBUGFS\n \tstruct hlist_head mem_head;\n \tspinlock_t mem_head_lock;\n+\tstruct debugfs_u32_array dfs_bitmap;\n #endif\n \tconst char *name;\n };\n'}, {'old_path': 'mm/cma_debug.c', 'new_path': 'mm/cma_debug.c', 'a_mode': '100644', 'b_mode': '100644', 'new_file': False, 'renamed_file': False, 'deleted_file': False, 'diff': '@@ -166,7 +166,6 @@ static void cma_debugfs_add_one(struct cma *cma, int idx)\n {\n \tstruct dentry *tmp;\n \tchar name[16];\n-\tint u32s;\n \n \tscnprintf(name, sizeof(name), "cma-%s", cma->name);\n \n@@ -182,8 +181,10 @@ static void cma_debugfs_add_one(struct cma *cma, int idx)\n \tdebugfs_create_file("used", 0444, tmp, cma, &cma_used_fops);\n \tdebugfs_create_file("maxchunk", 0444, tmp, cma, &cma_maxchunk_fops);\n \n-\tu32s = DIV_ROUND_UP(cma_bitmap_maxno(cma), BITS_PER_BYTE * sizeof(u32));\n-\tdebugfs_create_u32_array("bitmap", 0444, tmp, (u32 *)cma->bitmap, u32s);\n+\tcma->dfs_bitmap.array = (u32 *)cma->bitmap;\n+\tcma->dfs_bitmap.n_elements = DIV_ROUND_UP(cma_bitmap_maxno(cma),\n+\t\t\t\t\t\t  BITS_PER_BYTE * sizeof(u32));\n+\tdebugfs_create_u32_array("bitmap", 0444, tmp, &cma->dfs_bitmap);\n }\n \n static int __init cma_debugfs_init(void)\n'}]
2020-10-14T15:44:56.432 - [INFO] - cki.webhook.bugzilla - {'old_path': 'Documentation/filesystems/debugfs.txt', 'new_path': 'Documentation/filesystems/debugfs.txt', 'a_mode': '100644', 'b_mode': '100644', 'new_file': False, 'renamed_file': False, 'deleted_file': False, 'diff': '@@ -178,13 +178,17 @@ byte offsets over a base for the register block.\n \n If you want to dump an u32 array in debugfs, you can create file with:\n \n+    struct debugfs_u32_array {\n+\tu32 *array;\n+\tu32 n_elements;\n+    };\n+\n     void debugfs_create_u32_array(const char *name, umode_t mode,\n \t\t\tstruct dentry *parent,\n-\t\t\tu32 *array, u32 elements);\n+\t\t\tstruct debugfs_u32_array *array);\n \n-The "array" argument provides data, and the "elements" argument is\n-the number of elements in the array. Note: Once array is created its\n-size can not be changed.\n+The "array" argument wraps a pointer to the array\'s data and the number\n+of its elements. Note: Once array is created its size can not be changed.\n \n There is a helper function to create device related seq_file:\n \n'}
2020-10-14T15:44:56.573 - [DEBUG] - cki.cki_lib.gitlab - Requested: https://gitlab.com/api/v4/projects/20363472/repository/commits/6cdff6f9ce26fecea9105d91900c8ff68c5bf3d4
2020-10-14T15:44:56.722 - [DEBUG] - cki.cki_lib.gitlab - Requested: https://gitlab.com/api/v4/projects/20363472/repository/commits/6cdff6f9ce26fecea9105d91900c8ff68c5bf3d4/diff
2020-10-14T15:44:56.722 - [INFO] - cki.webhook.bugzilla - [{'old_path': 'Documentation/filesystems/debugfs.txt', 'new_path': 'Documentation/filesystems/debugfs.txt', 'a_mode': '100644', 'b_mode': '100644', 'new_file': False, 'renamed_file': False, 'deleted_file': False, 'diff': '@@ -178,7 +178,7 @@ byte offsets over a base for the register block.\n \n If you want to dump an u32 array in debugfs, you can create file with:\n \n-    struct dentry *debugfs_create_u32_array(const char *name, umode_t mode,\n+    void debugfs_create_u32_array(const char *name, umode_t mode,\n \t\t\tstruct dentry *parent,\n \t\t\tu32 *array, u32 elements);\n \n'}, {'old_path': 'fs/debugfs/file.c', 'new_path': 'fs/debugfs/file.c', 'a_mode': '100644', 'b_mode': '100644', 'new_file': False, 'renamed_file': False, 'deleted_file': False, 'diff': '@@ -1027,25 +1027,19 @@ static const struct file_operations u32_array_fops = {\n  * @array as data. If the @mode variable is so set it can be read from.\n  * Writing is not supported. Seek within the file is also not supported.\n  * Once array is created its size can not be changed.\n- *\n- * The function returns a pointer to dentry on success. If an error occurs,\n- * %ERR_PTR(-ERROR) or NULL will be returned. If debugfs is not enabled in\n- * the kernel, the value %ERR_PTR(-ENODEV) will be returned.\n  */\n-struct dentry *debugfs_create_u32_array(const char *name, umode_t mode,\n-\t\t\t\t\t    struct dentry *parent,\n-\t\t\t\t\t    u32 *array, u32 elements)\n+void debugfs_create_u32_array(const char *name, umode_t mode,\n+\t\t\t      struct dentry *parent, u32 *array, u32 elements)\n {\n \tstruct array_data *data = kmalloc(sizeof(*data), GFP_KERNEL);\n \n \tif (data == NULL)\n-\t\treturn NULL;\n+\t\treturn;\n \n \tdata->array = array;\n \tdata->elements = elements;\n \n-\treturn debugfs_create_file_unsafe(name, mode, parent, data,\n-\t\t\t\t\t&u32_array_fops);\n+\tdebugfs_create_file_unsafe(name, mode, parent, data, &u32_array_fops);\n }\n EXPORT_SYMBOL_GPL(debugfs_create_u32_array);\n \n'}, {'old_path': 'include/linux/debugfs.h', 'new_path': 'include/linux/debugfs.h', 'a_mode': '100644', 'b_mode': '100644', 'new_file': False, 'renamed_file': False, 'deleted_file': False, 'diff': '@@ -133,9 +133,8 @@ struct dentry *debugfs_create_regset32(const char *name, umode_t mode,\n void debugfs_print_regs32(struct seq_file *s, const struct debugfs_reg32 *regs,\n \t\t\t  int nregs, void __iomem *base, char *prefix);\n \n-struct dentry *debugfs_create_u32_array(const char *name, umode_t mode,\n-\t\t\t\t\tstruct dentry *parent,\n-\t\t\t\t\tu32 *array, u32 elements);\n+void debugfs_create_u32_array(const char *name, umode_t mode,\n+\t\t\t      struct dentry *parent, u32 *array, u32 elements);\n \n struct dentry *debugfs_create_devm_seqfile(struct device *dev, const char *name,\n \t\t\t\t\t   struct dentry *parent,\n@@ -353,11 +352,10 @@ static inline bool debugfs_initialized(void)\n \treturn false;\n }\n \n-static inline struct dentry *debugfs_create_u32_array(const char *name, umode_t mode,\n-\t\t\t\t\tstruct dentry *parent,\n-\t\t\t\t\tu32 *array, u32 elements)\n+static inline void debugfs_create_u32_array(const char *name, umode_t mode,\n+\t\t\t\t\t    struct dentry *parent, u32 *array,\n+\t\t\t\t\t    u32 elements)\n {\n-\treturn ERR_PTR(-ENODEV);\n }\n \n static inline struct dentry *debugfs_create_devm_seqfile(struct device *dev,\n'}]
2020-10-14T15:44:56.723 - [INFO] - cki.webhook.bugzilla - {'old_path': 'Documentation/filesystems/debugfs.txt', 'new_path': 'Documentation/filesystems/debugfs.txt', 'a_mode': '100644', 'b_mode': '100644', 'new_file': False, 'renamed_file': False, 'deleted_file': False, 'diff': '@@ -178,7 +178,7 @@ byte offsets over a base for the register block.\n \n If you want to dump an u32 array in debugfs, you can create file with:\n \n-    struct dentry *debugfs_create_u32_array(const char *name, umode_t mode,\n+    void debugfs_create_u32_array(const char *name, umode_t mode,\n \t\t\tstruct dentry *parent,\n \t\t\tu32 *array, u32 elements);\n \n'}
2020-10-14T15:44:56.873 - [DEBUG] - cki.cki_lib.gitlab - Requested: https://gitlab.com/api/v4/projects/20363472/repository/commits/d171d071d367c55085978e0a4746d1426af46eea
2020-10-14T15:44:57.032 - [DEBUG] - cki.cki_lib.gitlab - Requested: https://gitlab.com/api/v4/projects/20363472/repository/commits/d171d071d367c55085978e0a4746d1426af46eea/diff
2020-10-14T15:44:57.032 - [INFO] - cki.webhook.bugzilla - [{'old_path': 'Documentation/filesystems/debugfs.txt', 'new_path': 'Documentation/filesystems/debugfs.txt', 'a_mode': '100644', 'b_mode': '100644', 'new_file': False, 'renamed_file': False, 'deleted_file': False, 'diff': "@@ -31,10 +31,10 @@ This call, if successful, will make a directory called name underneath the\n indicated parent directory.  If parent is NULL, the directory will be\n created in the debugfs root.  On success, the return value is a struct\n dentry pointer which can be used to create files in the directory (and to\n-clean it up at the end).  A NULL return value indicates that something went\n-wrong.  If ERR_PTR(-ENODEV) is returned, that is an indication that the\n-kernel has been built without debugfs support and none of the functions\n-described below will work.\n+clean it up at the end).  An ERR_PTR(-ERROR) return value indicates that\n+something went wrong.  If ERR_PTR(-ENODEV) is returned, that is an\n+indication that the kernel has been built without debugfs support and none\n+of the functions described below will work.\n \n The most general way to create a file within a debugfs directory is with:\n \n@@ -48,8 +48,9 @@ should hold the file, data will be stored in the i_private field of the\n resulting inode structure, and fops is a set of file operations which\n implement the file's behavior.  At a minimum, the read() and/or write()\n operations should be provided; others can be included as needed.  Again,\n-the return value will be a dentry pointer to the created file, NULL for\n-error, or ERR_PTR(-ENODEV) if debugfs support is missing.\n+the return value will be a dentry pointer to the created file,\n+ERR_PTR(-ERROR) on error, or ERR_PTR(-ENODEV) if debugfs support is\n+missing.\n \n Create a file with an initial size, the following function can be used\n instead:\n@@ -223,7 +224,8 @@ can be removed with:\n \n     void debugfs_remove(struct dentry *dentry);\n \n-The dentry value can be NULL, in which case nothing will be removed.\n+The dentry value can be NULL or an error value, in which case nothing will\n+be removed.\n \n Once upon a time, debugfs users were required to remember the dentry\n pointer for every debugfs file they created so that all files could be\n"}, {'old_path': 'fs/debugfs/file.c', 'new_path': 'fs/debugfs/file.c', 'a_mode': '100644', 'b_mode': '100644', 'new_file': False, 'renamed_file': False, 'deleted_file': False, 'diff': '@@ -424,12 +424,11 @@ DEFINE_DEBUGFS_ATTRIBUTE(fops_u8_wo, NULL, debugfs_u8_set, "%llu\\n");\n  * This function will return a pointer to a dentry if it succeeds.  This\n  * pointer must be passed to the debugfs_remove() function when the file is\n  * to be removed (no automatic cleanup happens if your module is unloaded,\n- * you are responsible here.)  If an error occurs, %NULL will be returned.\n+ * you are responsible here.)  If an error occurs, %ERR_PTR(-ERROR) will be\n+ * returned.\n  *\n- * If debugfs is not enabled in the kernel, the value -%ENODEV will be\n- * returned.  It is not wise to check for this value, but rather, check for\n- * %NULL or !%NULL instead as to eliminate the need for #ifdef in the calling\n- * code.\n+ * If debugfs is not enabled in the kernel, the value %ERR_PTR(-ENODEV) will\n+ * be returned.\n  */\n struct dentry *debugfs_create_u8(const char *name, umode_t mode,\n \t\t\t\t struct dentry *parent, u8 *value)\n@@ -470,12 +469,11 @@ DEFINE_DEBUGFS_ATTRIBUTE(fops_u16_wo, NULL, debugfs_u16_set, "%llu\\n");\n  * This function will return a pointer to a dentry if it succeeds.  This\n  * pointer must be passed to the debugfs_remove() function when the file is\n  * to be removed (no automatic cleanup happens if your module is unloaded,\n- * you are responsible here.)  If an error occurs, %NULL will be returned.\n+ * you are responsible here.)  If an error occurs, %ERR_PTR(-ERROR) will be\n+ * returned.\n  *\n- * If debugfs is not enabled in the kernel, the value -%ENODEV will be\n- * returned.  It is not wise to check for this value, but rather, check for\n- * %NULL or !%NULL instead as to eliminate the need for #ifdef in the calling\n- * code.\n+ * If debugfs is not enabled in the kernel, the value %ERR_PTR(-ENODEV) will\n+ * be returned.\n  */\n struct dentry *debugfs_create_u16(const char *name, umode_t mode,\n \t\t\t\t  struct dentry *parent, u16 *value)\n@@ -516,12 +514,11 @@ DEFINE_DEBUGFS_ATTRIBUTE(fops_u32_wo, NULL, debugfs_u32_set, "%llu\\n");\n  * This function will return a pointer to a dentry if it succeeds.  This\n  * pointer must be passed to the debugfs_remove() function when the file is\n  * to be removed (no automatic cleanup happens if your module is unloaded,\n- * you are responsible here.)  If an error occurs, %NULL will be returned.\n+ * you are responsible here.)  If an error occurs, %ERR_PTR(-ERROR) will be\n+ * returned.\n  *\n- * If debugfs is not enabled in the kernel, the value -%ENODEV will be\n- * returned.  It is not wise to check for this value, but rather, check for\n- * %NULL or !%NULL instead as to eliminate the need for #ifdef in the calling\n- * code.\n+ * If debugfs is not enabled in the kernel, the value %ERR_PTR(-ENODEV) will\n+ * be returned.\n  */\n struct dentry *debugfs_create_u32(const char *name, umode_t mode,\n \t\t\t\t struct dentry *parent, u32 *value)\n@@ -563,12 +560,11 @@ DEFINE_DEBUGFS_ATTRIBUTE(fops_u64_wo, NULL, debugfs_u64_set, "%llu\\n");\n  * This function will return a pointer to a dentry if it succeeds.  This\n  * pointer must be passed to the debugfs_remove() function when the file is\n  * to be removed (no automatic cleanup happens if your module is unloaded,\n- * you are responsible here.)  If an error occurs, %NULL will be returned.\n+ * you are responsible here.)  If an error occurs, %ERR_PTR(-ERROR) will be\n+ * returned.\n  *\n- * If debugfs is not enabled in the kernel, the value -%ENODEV will be\n- * returned.  It is not wise to check for this value, but rather, check for\n- * %NULL or !%NULL instead as to eliminate the need for #ifdef in the calling\n- * code.\n+ * If debugfs is not enabled in the kernel, the value %ERR_PTR(-ENODEV) will\n+ * be returned.\n  */\n struct dentry *debugfs_create_u64(const char *name, umode_t mode,\n \t\t\t\t struct dentry *parent, u64 *value)\n@@ -612,12 +608,11 @@ DEFINE_DEBUGFS_ATTRIBUTE(fops_ulong_wo, NULL, debugfs_ulong_set, "%llu\\n");\n  * This function will return a pointer to a dentry if it succeeds.  This\n  * pointer must be passed to the debugfs_remove() function when the file is\n  * to be removed (no automatic cleanup happens if your module is unloaded,\n- * you are responsible here.)  If an error occurs, %NULL will be returned.\n+ * you are responsible here.)  If an error occurs, %ERR_PTR(-ERROR) will be\n+ * returned.\n  *\n- * If debugfs is not enabled in the kernel, the value -%ENODEV will be\n- * returned.  It is not wise to check for this value, but rather, check for\n- * %NULL or !%NULL instead as to eliminate the need for #ifdef in the calling\n- * code.\n+ * If debugfs is not enabled in the kernel, the value %ERR_PTR(-ENODEV) will\n+ * be returned.\n  */\n struct dentry *debugfs_create_ulong(const char *name, umode_t mode,\n \t\t\t\t    struct dentry *parent, unsigned long *value)\n@@ -880,12 +875,11 @@ static const struct file_operations fops_bool_wo = {\n  * This function will return a pointer to a dentry if it succeeds.  This\n  * pointer must be passed to the debugfs_remove() function when the file is\n  * to be removed (no automatic cleanup happens if your module is unloaded,\n- * you are responsible here.)  If an error occurs, %NULL will be returned.\n+ * you are responsible here.)  If an error occurs, %ERR_PTR(-ERROR) will be\n+ * returned.\n  *\n- * If debugfs is not enabled in the kernel, the value -%ENODEV will be\n- * returned.  It is not wise to check for this value, but rather, check for\n- * %NULL or !%NULL instead as to eliminate the need for #ifdef in the calling\n- * code.\n+ * If debugfs is not enabled in the kernel, the value %ERR_PTR(-ENODEV) will\n+ * be returned.\n  */\n struct dentry *debugfs_create_bool(const char *name, umode_t mode,\n \t\t\t\t   struct dentry *parent, bool *value)\n@@ -934,12 +928,11 @@ static const struct file_operations fops_blob = {\n  * This function will return a pointer to a dentry if it succeeds.  This\n  * pointer must be passed to the debugfs_remove() function when the file is\n  * to be removed (no automatic cleanup happens if your module is unloaded,\n- * you are responsible here.)  If an error occurs, %NULL will be returned.\n+ * you are responsible here.)  If an error occurs, %ERR_PTR(-ERROR) will be\n+ * returned.\n  *\n- * If debugfs is not enabled in the kernel, the value -%ENODEV will be\n- * returned.  It is not wise to check for this value, but rather, check for\n- * %NULL or !%NULL instead as to eliminate the need for #ifdef in the calling\n- * code.\n+ * If debugfs is not enabled in the kernel, the value %ERR_PTR(-ENODEV) will\n+ * be returned.\n  */\n struct dentry *debugfs_create_blob(const char *name, umode_t mode,\n \t\t\t\t   struct dentry *parent,\n@@ -1035,8 +1028,9 @@ static const struct file_operations u32_array_fops = {\n  * Writing is not supported. Seek within the file is also not supported.\n  * Once array is created its size can not be changed.\n  *\n- * The function returns a pointer to dentry on success. If debugfs is not\n- * enabled in the kernel, the value -%ENODEV will be returned.\n+ * The function returns a pointer to dentry on success. If an error occurs,\n+ * %ERR_PTR(-ERROR) or NULL will be returned. If debugfs is not enabled in\n+ * the kernel, the value %ERR_PTR(-ENODEV) will be returned.\n  */\n struct dentry *debugfs_create_u32_array(const char *name, umode_t mode,\n \t\t\t\t\t    struct dentry *parent,\n@@ -1132,12 +1126,11 @@ static const struct file_operations fops_regset32 = {\n  * This function will return a pointer to a dentry if it succeeds.  This\n  * pointer must be passed to the debugfs_remove() function when the file is\n  * to be removed (no automatic cleanup happens if your module is unloaded,\n- * you are responsible here.)  If an error occurs, %NULL will be returned.\n+ * you are responsible here.)  If an error occurs, %ERR_PTR(-ERROR) will be\n+ * returned.\n  *\n- * If debugfs is not enabled in the kernel, the value -%ENODEV will be\n- * returned.  It is not wise to check for this value, but rather, check for\n- * %NULL or !%NULL instead as to eliminate the need for #ifdef in the calling\n- * code.\n+ * If debugfs is not enabled in the kernel, the value %ERR_PTR(-ENODEV) will\n+ * be returned.\n  */\n struct dentry *debugfs_create_regset32(const char *name, umode_t mode,\n \t\t\t\t       struct dentry *parent,\n'}]
2020-10-14T15:44:57.033 - [INFO] - cki.webhook.bugzilla - {'old_path': 'Documentation/filesystems/debugfs.txt', 'new_path': 'Documentation/filesystems/debugfs.txt', 'a_mode': '100644', 'b_mode': '100644', 'new_file': False, 'renamed_file': False, 'deleted_file': False, 'diff': "@@ -31,10 +31,10 @@ This call, if successful, will make a directory called name underneath the\n indicated parent directory.  If parent is NULL, the directory will be\n created in the debugfs root.  On success, the return value is a struct\n dentry pointer which can be used to create files in the directory (and to\n-clean it up at the end).  A NULL return value indicates that something went\n-wrong.  If ERR_PTR(-ENODEV) is returned, that is an indication that the\n-kernel has been built without debugfs support and none of the functions\n-described below will work.\n+clean it up at the end).  An ERR_PTR(-ERROR) return value indicates that\n+something went wrong.  If ERR_PTR(-ENODEV) is returned, that is an\n+indication that the kernel has been built without debugfs support and none\n+of the functions described below will work.\n \n The most general way to create a file within a debugfs directory is with:\n \n@@ -48,8 +48,9 @@ should hold the file, data will be stored in the i_private field of the\n resulting inode structure, and fops is a set of file operations which\n implement the file's behavior.  At a minimum, the read() and/or write()\n operations should be provided; others can be included as needed.  Again,\n-the return value will be a dentry pointer to the created file, NULL for\n-error, or ERR_PTR(-ENODEV) if debugfs support is missing.\n+the return value will be a dentry pointer to the created file,\n+ERR_PTR(-ERROR) on error, or ERR_PTR(-ENODEV) if debugfs support is\n+missing.\n \n Create a file with an initial size, the following function can be used\n instead:\n@@ -223,7 +224,8 @@ can be removed with:\n \n     void debugfs_remove(struct dentry *dentry);\n \n-The dentry value can be NULL, in which case nothing will be removed.\n+The dentry value can be NULL or an error value, in which case nothing will\n+be removed.\n \n Once upon a time, debugfs users were required to remember the dentry\n pointer for every debugfs file they created so that all files could be\n"}
2020-10-14T15:44:57.188 - [DEBUG] - cki.cki_lib.gitlab - Requested: https://gitlab.com/api/v4/projects/20363472/repository/branches?search=%5E8.
{
  "package": "kernel",
  "namespace": "rpms",
  "ref": "refs/heads/rhel-8.4.0",
  "commits": [
    {
      "hexsha": "HEAD",
      "files": [
        "kernel.spec"
      ],
      "resolved": [
        1867211
      ],
      "related": [],
      "reverted": []
    }
  ]
}
2020-10-14T15:45:02.487 - [DEBUG] - cki.webhook.bugzilla - Requested: https://dist-git.host.prod.eng.bos.redhat.com/lookaside/gitbz-query.cgi
{
  "result": "ok",
  "logs": "*** Checking commit HEAD\n*** Resolves:\n***   Approved:\n***     rhbz#1867211 (qe_test_coverage?, qa_ack+, internal_target_release=8.4.0, devel_ack+, mirror+, release+, rpl+)\n*** Commit HEAD allowed\n*** http://pkgs.devel.redhat.com/cgit/rpms/kernel/commit/?h=rhel-8.4.0&id=HEAD\n"
}
2020-10-14T15:45:02.490 - [INFO] - cki.webhook.bugzilla - Skipping adding BZ report in non-production
2020-10-14T15:45:02.490 - [DEBUG] - cki.webhook.bugzilla -

BZ Readiness Report

|1867211|85d22299 6cdff6f9 (...)|True||

Merge Request passes bz validation

2020-10-14T15:45:02.491 - [DEBUG] - cki.webhook.bugzilla - Updating MR current state to State.BZVALID
2020-10-14T15:45:02.491 - [DEBUG] - cki.webhook.bugzilla - Checking CI state

2020-10-14T15:45:02.491 - [DEBUG] - cki.webhook.bugzilla - Cehcking MR pipeline result

2020-10-14T15:45:02.491 - [DEBUG] - cki.webhook.bugzilla - Updating MR current state to State.CIBZVALID
2020-10-14T15:45:02.651 - [DEBUG] - cki.cki_lib.gitlab - Requested: https://gitlab.com/api/v4/projects/20363472/merge_requests/68/approvals
2020-10-14T15:45:02.652 - [INFO] - cki.webhook.bugzilla - We have 0 approvals
2020-10-14T15:45:02.652 - [DEBUG] - cki.webhook.bugzilla - Computed next state as State.CIBZVALID
[tcamuso@dhcp40-158 webhooks]$ export GITLAB_TOKENS='{"gitlab.com": "COM_GITLAB_TOKEN"}'


