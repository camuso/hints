# !text
#

# Prep
# ====

# Make sure you have the RCM tools repo.
#
# rhel-10: https://download.devel.redhat.com/rel-eng/RCMTOOLS/rcm-tools-rhel-10-baseos.repo
# rhel-9:  https://download.devel.redhat.com/rel-eng/RCMTOOLS/rcm-tools-rhel-9-baseos.repo
# Fedora:  https://download.devel.redhat.com/rel-eng/RCMTOOLS/rcm-tools-fedora.repo

$ sudo su -
$ cd /etc/yum.repos.d
$ curl -o rcmtools.repo \
  https://download.devel.redhat.com/rel-eng/RCMTOOLS/rcm-tools-rhel-9-baseos.repo

# Install or update
#   brewkoji
#   rhpkg
#   rhel-packager
#   centpkg

$ dnf install -y brewkoji rhpkg rhel-packager centos

# You should build rpm images natively, i.e, rhel-10 on a rhel-10
# provisioned system.

# Directory tree:

/work --+--- pigz --+-- cs	# For CentOs side
        |           |
	|           +-- rh	# For RHEL side
	:

# CENTOS side
# ===========

$ cd /work/pigz
$ centpkg co pigz cs
$ cd cs
$ git branch -r
  origin/HEAD -> origin/c10s
  origin/c10s
  origin/c8s
  origin/c9s

## If it doesn't exist, create your fork using the gitlab web ui.
## Go to https://gitlab.com/dashboard/projects
## Use the search bar to find the project, e.g. pigz
## Click on the Red Hat / centos-stream / rpms / pigz link
## In the upper right hand corner, click on Fork and go through
## the guided interface to create your fork.
##
## Your username, e.g. tcamuso, is the namespace. Start typing
## it into the droplist and select it when it appears.
## Do NOT press RETURN!
##
## Press "Fork Project" at the bottom of the fork Web UI.
##
## In your directory, add your fork.

$ git remote add tcamuso git@gitlab.com:tcamuso/pigz.git
$ git remote -v
origin git+ssh://git@gitlab.com/redhat/centos-stream/rpms/pigz.git (fetch)
origin git+ssh://git@gitlab.com/redhat/centos-stream/rpms/pigz.git (push)
tcamuso        git@gitlab.com:tcamuso/pigz.git (fetch)
tcamuso        git@gitlab.com:tcamuso/pigz.git (push)

##  get on the right branch
$ git checkout origin/c9s
Switched to branch '9'
Your branch is up to date with 'origin/c9s'.

## Checkout a working branch using the Jira issue number for the
## working-branch
$ workingbranch="<jira-nuber>
$ git checkout -b "$workingbranch"

## make and commit changes
## Get the new tar file.
## For tboot ...
$ curl -L \
        https://sourceforge.net/projects/tboot/files/latest/download?source=files \
        -o tboot-1.11.9.tar.gz
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   611  100   611    0     0   2923      0 --:--:-- --:--:-- --:--:--  2937
100   353  100   353    0     0    735      0 --:--:-- --:--:-- --:--:--   735
100  906k  100  906k    0     0   811k      0  0:00:01  0:00:01 --:--:-- 2209k
$

## For pigz
##
$ wget https://zlib.net/pigz/pigz-2.8.tar.gz

## For tboot
##
wget -O tboot-1.11.10.tar.gz \
  https://sourceforge.net/projects/tboot/files/tboot-1.11.10.tar.gz/download

## For intel-cmt-cat
##
wget -O intel-cmt-cat-25.04.tar.gz \
	     https://github.com/intel/intel-cmt-cat/releases/tag/v25.04

# NOTE: Uppercase O in the wget command.

## Push the new tar file into the centos-stream.
$ centpkg upload pigz-2.8.tar.gz

# NOTE:
#   If you MUST re-upload a tarball with the same name.version,
#   use...
$ centpkg new-sources intel-cmt-cat-25.04.tar.gz

## That should change the sources file in your current directory,
## so that git status will show the source diff to have the new
## version number of the upstream tar file.

# Make your edits, updates, rebase, etc.
# Update the .spec file to the appropriate NVR.
# - Update the changelog in the .spec file and be sure to include
#   Resolves: RHEL-<Jira-number>
#
# Test the build
# For some reason I don't yet understand, rhpkg local won't do this.
 $ centpkg local

# Make necessary changes until the build succeeds.
# Run tests on the resulting package from the build.
# If the build and tests succeed, commit your changes.
$ git commit . -s
#
# Be sure to add the following to the commit message.
# Resolves: RHEL-<Jira-number>
#
# Now push your changes to your fork
$ git push tcamuso "$workingbranch"

# The push will give you a link to a new MR. Go to that link
# and fill out the new MR. Opt for AutoMerge and delete branch
# when merged.
# NOTE:
#   MAKE SURE THAT YOU ARE MERGING INTO THE CORRECT BRANCH!
#   THE DEFAULT IS c10s !!
#
# The CKI test will likely fail, so the branch won't merge
# until you prep the RHEL side.

##  Create the MR and go through the process of getting merged.
##  (magic occurs here...    :-/   )

# =========
# RHEL side
# =========

# Get the RHEL version of the package.
$ cd /work/pigz
$ rhpkg co pigz rh
$ cd rh
$ git checkout rhel-9-main
# In this example, we are building for RHEL-9.6, but we must
# push RHEL-9.5.0 into the origin. This is a mystery to me,
# but nothing on the RHEL side works until you do this.
$ git push origin rhel-9-main:rhel-9.5.0

# For RHEL-10.2, push RHEL-10.1.
$ git push origin rhel-10-main:rhel-10.1

# NOTE:
# Be sure that the JIRA has the "Fixed-In" field updated!
# The MR will fail the "Ticket" test without this.
#
# Go back to the MR for c9s that you created and rerun the ticket
# test that if it failed. After the above RHEL side prep, it should
# now succeed.
#
# After your MR has been merged, you must pull the changes into
# the cs side.

$ cd ../cs

# Checkout the main branch and update it.
$ git checkout c10s
$ git pull

# You should see a git update.
# Check the git log to be sure your changes are there.
# If all is well, built the release rpm
# Do a scratch build to see that it all works without errors.
$ centpkg local

# If all is well, do the main build
$ centpkg build

# That should kick-off the whole errata thing.
# You will receive email from [CI] [GATING] [INFO]
# Look in that email for any problems that need fixing # or waiving.
#
# After CI GATING is satified, you will receive email from
# [errata_automation]. The errata cannot be addressed until the
# Preliminary testing is completed by the RTT.

##  Preliminary testing 'Requested' should be set by the Jira bot,
##  If not, in the Jira: Edit > Development
##
##  After QA does their job and sets Pass, the automation will create an
##  erratum (in NEW_FILES), which will have to be moved to the QE state.
#
##  When you are notified that the Errata has been created, log into
##  the Errata and move it to QE
##
